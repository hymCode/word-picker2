// Generated by CoffeeScript 1.10.0
(function() {
  var Picker, util;

  util = require('./util');

  Picker = (function() {
    function Picker(option) {
      if (option == null) {
        option = {};
      }
      this.data = {
        wordMaxLen: option.wordMaxLen || 20,
        wordMinLen: option.wordMinLen || 2,
        likeSymbol: option.likeSymbol || '%'
      };
      this._init();
    }

    Picker.prototype._init = function() {
      this.wordMap = {};
      this.wordLikeMap = {};
      return this.wordLikeTree = {};
    };

    Picker.prototype._loadWordLib = function(lib) {
      if (typeof lib === 'string') {
        return this._loadLibFromFile(lib);
      } else if (lib instanceof Array) {
        return this._loadLibFromArray(lib);
      }
    };

    Picker.prototype._loadLibFromFile = function(filename) {
      var wordList;
      try {
        wordList = require('fs').readFileSync(filename).toString('utf-8').split('\n');
        return this._loadLibFromArray(wordList);
      } catch (undefined) {}
    };

    Picker.prototype._loadLibFromArray = function(wordList) {
      var k, len, len1, likeSymbol, results, word;
      if (wordList == null) {
        wordList = [];
      }
      likeSymbol = this.data.likeSymbol;
      results = [];
      for (k = 0, len1 = wordList.length; k < len1; k++) {
        word = wordList[k];
        word = word.replace(/\s/, '');
        len = word.length;
        if (len < this.data.wordMinLen || len > this.data.wordMaxLen) {
          continue;
        }
        if (word.indexOf(likeSymbol) === -1) {
          this.wordMap[word] = true;
          continue;
        }
        results.push(((function(_this) {
          return function() {
            var results1, tmp, words;
            tmp = _this.wordLikeTree;
            words = word.split(likeSymbol);
            words = util.unique(words).sort();
            results1 = [];
            while (words.length > 0) {
              word = words.shift();
              _this.wordLikeMap[word] = true;
              if (!tmp[word]) {
                tmp[word] = {
                  branch: {}
                };
              }
              if (words.length === 0) {
                tmp[word].isLeaf = true;
              }
              results1.push(tmp = tmp[word].branch);
            }
            return results1;
          };
        })(this))());
      }
      return results;
    };

    Picker.prototype._doPicker = function(str) {
      var i, j, k, l, leafArr, m, n, ref, ref1, ref2, ref3, ref4, retWordLikeMap, retWordMap, strLen, word, wordLikeArr, wordMaxLen;
      if (str == null) {
        str = '';
      }
      str = str.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '');
      strLen = str.length;
      retWordMap = {};
      retWordLikeMap = {};
      wordMaxLen = this.data.wordMaxLen - strLen > 0 ? strLen : this.data.wordMaxLen;
      for (i = k = ref = this.data.wordMinLen, ref1 = wordMaxLen; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
        for (j = l = 0, ref2 = strLen - i; 0 <= ref2 ? l <= ref2 : l >= ref2; j = 0 <= ref2 ? ++l : --l) {
          word = str.substr(j, i);
          if (word && this.wordMap[word]) {
            retWordMap[word] = true;
          }
        }
      }
      for (i = m = 1, ref3 = wordMaxLen; 1 <= ref3 ? m <= ref3 : m >= ref3; i = 1 <= ref3 ? ++m : --m) {
        for (j = n = 0, ref4 = strLen - i; 0 <= ref4 ? n <= ref4 : n >= ref4; j = 0 <= ref4 ? ++n : --n) {
          word = str.substr(j, i);
          if (word && this.wordLikeMap[word]) {
            retWordLikeMap[word] = true;
          }
        }
      }
      leafArr = util.keys(retWordLikeMap).sort();
      wordLikeArr = this._findExistsPath(leafArr);
      return util.unique(util.keys(retWordMap).concat(wordLikeArr));
    };

    Picker.prototype._findExistsPath = function(leafArr, map, parent) {
      var fn, ifRoot, k, leaf, len1, likeSymbol, tmp;
      if (map == null) {
        map = this.wordLikeTree;
      }
      if (parent == null) {
        parent = '';
      }
      tmp = [];
      ifRoot = !parent;
      likeSymbol = this.data.likeSymbol;
      fn = (function(_this) {
        return function() {
          var _parent, branch;
          if (ifRoot) {
            _parent = leaf;
          } else {
            _parent = parent + likeSymbol + leaf;
          }
          if (map[leaf]) {
            if (map[leaf].isLeaf) {
              tmp.push(_parent);
            }
            branch = map[leaf].branch;
            if (util.keys(branch).length > 0) {
              return tmp = tmp.concat(_this._findExistsPath(leafArr, branch, _parent));
            }
          }
        };
      })(this);
      for (k = 0, len1 = leafArr.length; k < len1; k++) {
        leaf = leafArr[k];
        fn();
      }
      return tmp;
    };

    Picker.prototype.doPicker = function(str) {
      return this._doPicker(str);
    };

    Picker.prototype.addLib = function(lib) {
      return this._loadWordLib(lib);
    };

    Picker.prototype.addlib = function(lib) {
      return this.addLib(lib);
    };

    Picker.prototype.reloadLib = function(lib) {
      this._init();
      return this.addLib(lib);
    };

    return Picker;

  })();

  module.exports = Picker;

}).call(this);

//# sourceMappingURL=Picker.js.map
